jQuery : ~2014
> JS 기본 & 근간

React.js : 2014~2020

Next.js : 2020~현재

Remix => F/E + B/E + AI

> 프레임워크 & 라이브러리 계속 진화한다!!! // 근본적인 스크립트 및 프로그래밍 언어에 대한 기본기와 이해!!!

useState( )

useRef( )

useEffect( )

useReducer( )

useMemo(callback, dep) : 어떤 컴포넌트를 마운트 시킬 때, 해당 컴포넌트 안에 있는 함수가 호출되었을 때, 반환되는 값을 기억해놓도록 하는 리액트 훅 함수!!!

useCallback(callback, dep) : 두번째로 입력된 의존성 배열의 값이 업데이트가 될 때에만 callback의 실행을 시키겠다!!!

useCallback 이라는 리액트 훅 함수를 사용하긴 하는데, 실제 콜백함수로 입력되는 해당 함수의 반환값을 전달해주는 또 다른 내부의 콜백함수의 인자값으로 state값을 전달해주면, 해당 state값은 의존성배열이 아무것도 없더라도 늘 항상 최신의 state값을 유지한다!!!

useContext( ) : 부모 > 자식요소 컴포넌트 (*Props) 전달 가능! 굳이 불필요한 요소를 거쳐서 Props를 전달하는 비효율적인 단계가 도출되고 있는 문제점 발견.확인!!!

> Context API를 활용해서 굉장히 특별한 컴포넌트를 하나 만들어놓고, 해당 컴포넌트의 범위에 들어온 자식 컴포넌트들에게 값을 직접적으로 전달할 수 있음 => 이때 자식 컴포넌트들 입장에서는 Context API가 제공하는 값을 그냥 가져올 수는 없고, useContext라는 훅 함수를 통해서만 찾아올 수 있음!!!
————————————

JS => 반복해서 사용하는 코드 => 한 번만 선언하고, 필요할 때마다 가져다 사용할 수 있도록 // 날짜객체 => 기념일 계산기!!!

100 / 200 / 300 / 500일

=> 프로그래밍 영역 : 코드 최적화
=> 브라우저 > JS 읽은 후 실행 시간 단축, 효율성 높아진다!!

=> “Memoization 기법” : 코드를 최적화하는 행위를 통틀어서 부르는 명칭
=> Dynamic Programming = 동적 계획법

App이라는 컴포넌트 존재

> todo 객체 => 컴포넌트 리렌더링!!
> 컴포넌트를 다시 재실행

> onUpdate 함수
> onDelete 함수

현재 해결해야하는 문제점 : todo 객체가 새롭게 업데이트가 됨으로 인해서 손주 컴포넌트에게 본의아닌 리렌더링을 시키고 있는 상황

todo 객체가 새롭게 생성되더라도 onUpdate 함수, onDelete 함수를 재호출하고 싶지 않음!!!

todo 객체가 추가 업데이트가 된다면, onCreate함수만 실행시키게 하겠다는 의미!!!!

A가 실행되면, B를 해라!!!

useContext

tailwind

JS 라이브러리

메모이제이션 기법 = 최적화를 위한 기법 => 반드시 프로젝트가 종료가되는 시기 혹은 지점에서 하는 것을 권장

1) 메모이제이션을 나중에 하려고 하다보면, 중간에 Props가 이동되는 경로 혹은 관리해야하는 state종류 들로 인해서 복잡함을 느낄 수 있음 => 메모이제이션을 그때그때마다 실행!!!

=> 어떤 역학관계에 놓여지는가에 따라서 최적화는 무용지물이 될 수 있음 => 최종적으로 컴포넌트 구조화가 거의 혹은 모두 마무리가 되었을 때 비로소 메모이제이션, 최적화를 해라!!!

폰트 및 배경 컬러 선택할 때, 참고사이트
1) web-gradients
2) flat ui colors
3) color hunt





